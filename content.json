{"meta":{"title":"hbinnn's Blog","subtitle":null,"description":null,"author":"hbinnn","url":"http://hbinnn.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2022-01-23T05:48:07.000Z","updated":"2022-01-23T05:48:59.923Z","comments":true,"path":"categories/index.html","permalink":"http://hbinnn.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-23T05:56:40.000Z","updated":"2022-01-23T05:57:01.255Z","comments":true,"path":"tags/index.html","permalink":"http://hbinnn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"second blog","slug":"second-blog","date":"2022-01-23T05:58:29.000Z","updated":"2022-01-23T05:58:45.652Z","comments":true,"path":"2022/01/23/second-blog/","link":"","permalink":"http://hbinnn.github.io/2022/01/23/second-blog/","excerpt":"","text":"","categories":[{"name":"tu","slug":"tu","permalink":"http://hbinnn.github.io/source/categories/tu/"}],"tags":[{"name":"3","slug":"3","permalink":"http://hbinnn.github.io/source/tags/3/"}]},{"title":"first blog","slug":"first-blog","date":"2022-01-23T04:00:50.000Z","updated":"2022-01-23T05:49:36.411Z","comments":true,"path":"2022/01/23/first-blog/","link":"","permalink":"http://hbinnn.github.io/2022/01/23/first-blog/","excerpt":"","text":"初识多线程hello world单线程打印”hello world”的方式很简单，现在来启动一个独立线程来打印”hello world” 123456789101112131415#include &lt;thread&gt;#include &lt;iostream&gt;void print()&#123; std::cout &lt;&lt; &quot;hello world&quot; &lt;&lt; std::endl;&#125;int main()&#123; std::thread t(print); if(t.joinable()) &#123; t.join(); &#125;&#125; c++标准库对多线程的支持在&lt;thread&gt;头文件中。 在这里，初始线程是main，通过std::thread创建了一个thread对象来启动一个新线程，而将print函数作为这个新线程的初始函数。初始线程始于main，新线程始于hello。 std::thread&lt;thread&gt;头文件c++中管理线程的函数和类在&lt;thread&gt;中声明,主要有这些内容 1234567891011121314151617181920212223242526class thread &#123; /* member class */ class id; /* Constructor */ thread(); thread(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args); thread(thread&amp;&amp; t); thread&amp; operator=(thread&amp;&amp; __t); /* Destructor */ ~thread(); /* Observers */ bool joinable(); thread::id get_id(); native_handle_type native_handle(); static unsigned int hardware_concurrency() /* Operations */ void join(); void detach(); void swap(thread&amp; __t);&#125;void swap( std::thread&amp; lhs, std::thread&amp; rhs ) 创建std::thread对象1234567891011121314151617181920212223242526std::thread t; // t仅仅是thread对象，并非一个线程，没有初始函数void func1();void func2(int);void func3(int&amp;);std::thread t1(func1); // 传递函数指针，无参数std::thread t2(func2, 1); // 值传递参数std::thread t3(func3, std::ref(n)); // 引用传递参数class Obj4 &#123;public: void func4(); static void func5();&#125;Obj4 obj4;std::thread t4(&amp;Obj::func4, obj4); // 传递非静态成员函数std::thread t5(&amp;Obj::func5); // 传递静态成员函数class Obj6 &#123;public: void operator()() const;&#125;;Obj6 obj6;std::thread t6(obj6); // 传递可调用对象std::thread t7([]&#123;return 0;&#125;) // 传递lambda表达式 join和detach在创建thread对象后需要调用join或detach来决定线程的运行方式。 join会阻塞主线程的执行，直到thread对象执行完毕返回之后再继续执行主线程。 detach则将thread对象与主线程分离，主线程不再等待thread对象执行完毕。 如果在thread对象销毁前没有决定出线程的运行方式，程序会终止。 因此要保证创建thread对象后调用join或detach。 同样多次调用join或detach也是不允许的。 std::thread的析构函数 12345~thread()&#123;if (joinable()) std::terminate();&#125; 在使用detach方式时应当注意，线程还未结束的时候主线程可能已经退出，线程函数不应该去访问已经销毁的变量。 123456789int i = 0;thread t4([&amp;]&#123; for (int j = 0; j &lt; 99999999; ++j) &#123; cout &lt;&lt; i &lt;&lt; endl; /* 潜在访问隐患 */ &#125;&#125;);if (t4.joinable()) &#123; t4.detach();&#125; joinablejoinable()函数是一个布尔类型的函数，他会返回一个布尔值来表示当前的线程是否是可执行线程(能被join或者detach)，因为相同的线程不能join两次，也不能join完再detach，同理也不能detach两次。 通常不能被joinable的情况有几种： 1、由thread的默认构造函数构造的thread对象； 2、该thread对象被move过； 3、该thread对象已经join或detach； RAII方式使用thread对象为了避免thread对象在创建后忘记调用join或detach而抛出异常，可以使用“资源获取即初始化方式”(RAII，Resource Acquisition Is Initialization) 12345678910111213141516171819class threadGuard &#123;public: explicit threadGuard(thread&amp; _t) : t(_t) &#123;&#125; ~threadGuard() &#123; if (t.joinable()) &#123; t.join(); &#125; &#125; private: thread&amp; t;&#125;;int main()&#123; thread t5(func); threadGuard tg(t5);&#125; 转移线程所有权std::thread对象是可移动但不可拷贝的。意味着执行线程的所有权可以在std::thread对象之间移动。可以使用std::move、移动构造函数、移动赋值函数来实现。 1234void func();std::thread t1(func);std::thread t2 = std::move(t1); // 此时线程的所有权从t1转移到t2t1 = std::thread(func); // 临时对象会隐式调用移动操作 在&lt;thread&gt;中，拷贝相关的操作都为delete。 1234thread(thread&amp;) = delete;thread(const thread&amp;) = delete;thread(const thread&amp;&amp;) = delete;thread&amp; operator=(const thread&amp;) = delete; 注意在使用移动赋值函数时，如果被赋值对象是可以joinable的，则会中止程序，但不会抛出异常。 1234void func();std::thread t1(func);std::thread t2(func);t2 = std::move(t1); // 会抛出异常 123456thread&amp; operator=(thread&amp;&amp; __t) noexcept&#123; if (joinable()) std::terminate(); swap(__t); return *this；&#125; 在std::thread对象被转移之后就变为不可joinable的，不能调用join或detach。 1234void func();std::thread t1(func);std::thread t2 = std::move(t1);t1.join(); // 抛出异常 在std::thread不可joinable的情况下转移所有权后再次join或detach也会抛出异常。 12345void func();std::thread t1(func);t1.join();std::thread t2 = std::move(t1);t2.join(); // 抛出异常 运行时决定线程数量std::thread::hardware_concurrency()函数返回可用硬件实现支持的并发线程数。该数值并不总是准确的。 表示线程std::thread对象通过std::thread::id来表示线程。有两种方式可以获取。 get_id()可以通过调用std::thread对象的成员函数get_id()来直接获取。如果该对象没有关联任何执行线程，则返回std::thread::id默认构造值，表示无线程。 std::this_thread::get_id()在当前线程中调用std::this_thread::get_id()函数来获取线程表示。 std::thread::id对象可以自由的拷贝和对比。 参考资料 std::thread - cppreference.com 第2章 线程管理 - 《C++ 并发编程实战 第二版 (C++ Concurrency in Action - SECOND EDITION)》 - 书栈网 · BookStack","categories":[{"name":"多线程","slug":"多线程","permalink":"http://hbinnn.github.io/source/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"2","slug":"2","permalink":"http://hbinnn.github.io/source/tags/2/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-23T03:58:17.421Z","updated":"2022-01-23T05:49:51.618Z","comments":true,"path":"2022/01/23/hello-world/","link":"","permalink":"http://hbinnn.github.io/2022/01/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"nothing","slug":"nothing","permalink":"http://hbinnn.github.io/source/categories/nothing/"}],"tags":[{"name":"1","slug":"1","permalink":"http://hbinnn.github.io/source/tags/1/"}]}],"categories":[{"name":"tu","slug":"tu","permalink":"http://hbinnn.github.io/source/categories/tu/"},{"name":"多线程","slug":"多线程","permalink":"http://hbinnn.github.io/source/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"nothing","slug":"nothing","permalink":"http://hbinnn.github.io/source/categories/nothing/"}],"tags":[{"name":"3","slug":"3","permalink":"http://hbinnn.github.io/source/tags/3/"},{"name":"2","slug":"2","permalink":"http://hbinnn.github.io/source/tags/2/"},{"name":"1","slug":"1","permalink":"http://hbinnn.github.io/source/tags/1/"}]}